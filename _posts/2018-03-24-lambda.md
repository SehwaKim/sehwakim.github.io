---
layout: post
title: JDK8 문법 - 람다표현식
---

람다식(Lambda Expression) 도입의 배경
-------------------------------------

함수란 매개변수를 가지고 어떤 동작을 한 다음에 리턴값이 반환되는 것을 말한다.  
메소드도 함수랑 같은 의미이다. 기본적인 틀은 매개변수를 가지고 메소드에 구현된 내용을 실행한 다음 리턴값을 반환한다.  
하지만 자바는 객체지향 언어이고 객체지향 관점에서 메소드는 단순히 함수라기 보단 객체의 동작을 나타내는 것이고 실제로도 반드시 클래스(객체) 내에 정의 되어 있어야 한다.  
보통 클래스를 설명할 때 *클래스는 객체_고 클래스 내의 _필드는 객체의 상태*, _메소드는 필드의 행위, 동작_이라고들 한다. 그래서 자바에서는 메소드를 함수라고 안하고 메소드라고 따로 이름을 붙여 부른다.  
자바의 메소드는 반드시 클래스 내에 정의 되어 있어야 하기때문에 바꿔 말하면 만약 어떠한 메소드가 필요하다고 하면 그 메소드가 속한 클래스도 반드시 필요하다.  
메소드의 기능적인 부분만 필요한데 그 기능 구현을 위해 클래스부터 새로 정의해야 되는 상황이 존재할 수 있는 것이다.  
또 정의만 하는게 아니라 그 객체의 인스턴스도 생성해야 비로소 내가 필요한 메소드를 호출해서 쓸 수 있다.  
이런 번거로움을 줄이고자 마치 순수한 의미의 함수처럼 필요한 메소드의 기능 그 자체만을 손쉽게 구현할 수 있게 해주는 것이 람다이고 이것이 람다의 탄생 배경이다.  
***람다식 자체가 메소드의 역할을 대신하고 그 자체가 함수인 것***이다.  
이로 인해 JDK1.8부터 자바는 이제 객체지향언어인 동시에 ***함수형언어***가 되었다.

람다식은

람다식의 만들기
---------------

`()->{}`  
이게 기본 적인 람다식의 구성이다. ()에는 매개변수 선언부가 들어가고, {}에는 기능적인 부분, 내용이 들어간다.  
기존 메소드 정의에서 _return타입_과 _메소드이름_이 제거되고 ()괄호 안의 매개변수 선언부는 살리고 {}중괄호 안의 메소드내용 구현부도 살려놓고 ()와 {}을 ->화살표로 이었다.  
리턴타입과 메소드이름이 제거됬기 때문에 람다식을 _익명 함수_라고도 한다.

그리고 이 람다식으로 된 함수는 하나의 변수에 담아 둘 수도 있다.

하나의 람다식은 함수형 인터페이스에 1:1 연결된다.

**@FunctionalInterface**  
inferface MyFunction {  
 public abstract int max(int a, int b);  
}  
함수형 인터페이스를 정의하는 방법이고 함수형 인터페이스에서는 오직 하나의 추상메소드만 정의되어있어야 한다는 제약이 있다. 그래야 람다식과 인터페이스가 1:1연결가능.

### 단순한 예제

"hello world"를 출력하는 스레드 만들기.  
`new Thread(new Runnable() { System.out.println("hello world"); } ).start();`

이것을 ()->{} 모양의 람다식으로 바꾸면 step 1) `new Thread( ()->{} ).start();` --> hello world를 출력하는 함수에 있어 어떠한 파라미터도 필요치않음. 그냥 ().  
 step 2) `new Thread( ()->{ System.out.println("hello world"); } ).start();`  
 --> {}부분에 실제 동작할 코드 작성.

이런식으로 식을 간결하게 만드는 것이 람다표현식이다.

### 람다식의 구조

-	( parameters ) -> expression body

-	( parameters ) -> { expression body }

-	() -> { expression body }

-	() -> expression body

위에서 보인 예시는 `() -> { expression body }`의 형식인 것이다.
